<html lang="en">
<head>
	<meta charset="UTF-8">
	<style>
		table {
			border-spacing: 0;
			margin: 0;
			padding: 0;
			
			border-right: 1px solid black;
			border-bottom: 1px solid black;
		}
		
		.tile {
			border-top: 1px solid black;
			border-left: 1px solid black;
			width: 70px;
			height: 70px;
			margin: 0;
		}

		tr:nth-child(2n), td:nth-child(2n)  {
			background-color: gray;
		}

		tr:nth-child(2n) td:nth-child(2n) {
			background-color: white;
		}

		td {
			text-align: center;
		}

		.figure {
			font-size: 50px;
		}

		.light {
			color: gold;
		}
	</style>
</head>
<body>

	<table>
		<tbody id="chessboard"></tbody>
	</table>

	<script>
		let currentField = '';

		const figures = {
			'bishop': {
				display: '&#9815;',
				field: '1_3'
			},
			'tower': { 
				display: '&#9814;',
				field: '1_1'
			},
			'knight': {
				display: '&#9816;',
				field: '1_2',
			},
		}

		const drawFigure = (figureName, figureData) => {
			const figureEL = document.createElement("span");
			figureEL.innerHTML = figureData['display'];
			figureEL.id = figureData['field'];
			figureEL.className = 'figure ' + figureName + (currentField == figureData['field'] ? ' light' : '');

			document.getElementById(figureData['field']).appendChild(figureEL);
		}

		/// deletes prev element and adds new one
		const updateFigure = (figureName, figureData) => {
			const element = document.getElementsByClassName(figureName);
			element[0].remove();

			drawFigure(figureName, figureData);
		}

		const isPossibleForBishop = (navigateTo) => {
			const from = currentField.split('_');
			const to = navigateTo.split('_');

			return Math.abs(from[0] - to[0]) == Math.abs(from[1] - to[1]);
		}

		const isPossibleForTower = (navigateTo) => {
			const from = currentField.split('_');
			const to = navigateTo.split('_');

			return from[0] === to[0] || from[1] === to[1];
		}

		const isPossibleForKnight = (navigateTo) => {
			const from = currentField.split('_');
			const to = navigateTo.split('_');

			return (Math.abs(from[0] - to[0]) == 1 && Math.abs(from[1] - to[1]) == 2) 
			|| (Math.abs(from[0] - to[0]) == 2 && Math.abs(from[1] - to[1]) == 1);
		}

		const isMovePossible = (figureName, fieldCoords) => {
			switch(figureName) {
				case 'bishop':
					return isPossibleForBishop(fieldCoords);
				case 'knight':
					return isPossibleForKnight(fieldCoords);
				case 'tower':
					return isPossibleForTower(fieldCoords);
				default:
					return false;
			}
		}

		const clearTileSelection = (figureOnCurrentTile) => {
			currentField = "";
			updateFigure(figureOnCurrentTile[0], figures[figureOnCurrentTile[0]]);
		}
		
		const onFieldClick = (ev) => {
			const fieldCoords = ev.target.id;
			const figureOnNewTile = Object.entries(figures).find((e) => e[1]['field'] === fieldCoords);
			const figureOnCurrentTile = Object.entries(figures).find((e) => e[1]['field'] === currentField);

			/// no figure is currently selected to be moved
			if(!figureOnCurrentTile) {
				currentField = fieldCoords;

				if(figureOnNewTile) 
					updateFigure(figureOnNewTile[0], figures[figureOnNewTile[0]]);

				return;
			}
			
			/// clicked on the same field
			if(fieldCoords == currentField) {
				clearTileSelection(figureOnCurrentTile);

				return;
			}

			/// try to move on tile with figure
			if(figureOnNewTile && figureOnCurrentTile) {
				alert ('This move is not allowed, as selected tile is already occupied');
				clearTileSelection(figureOnCurrentTile);

				return;
			}

			/// try to move on empty tile
			if(!figureOnNewTile && figureOnCurrentTile) { 
				let result = isMovePossible(figureOnCurrentTile[0], fieldCoords);
					
				if(result) {
					figures[figureOnCurrentTile[0]] = {
						'display': figureOnCurrentTile[1]['display'],
						'field': fieldCoords,
					}
				} else {
					alert ('This move is not allowed for ' + figureOnCurrentTile[0]);
				}
				
				clearTileSelection(figureOnCurrentTile);
				return;
			}
		}
		
		/// set up board
		const boardSize = 8;
		const array = Array.apply(0, Array(boardSize));
		const chessboard = document.getElementById("chessboard");

		array.forEach((_, oi) => {
			const horizontal = document.createElement("tr");
			
			array.forEach((_, ii) => {
				const tile = document.createElement("td");
				tile.className = 'tile';
				tile.id = (oi + 1) + '_' + (ii + 1);
				tile.addEventListener('click', onFieldClick);
				horizontal.appendChild(tile);
			});

			chessboard.appendChild(horizontal);
		})

		
		Object.entries(figures).forEach((el) => drawFigure(el[0], el[1]));
	</script>

</body>
</html>